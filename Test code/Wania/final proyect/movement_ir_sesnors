#include "open_interface.h"
#include "Timer.h"
#include <stdint.h>
#include "lcd.h"
#include <stdio.h>
#include <inc/tm4c123gh6pm.h>

void ADC_Init(void) {
    SYSCTL_RCGCADC_R |= 0x01;     // Enable ADC0 clock
    SYSCTL_RCGCGPIO_R |= 0x10;    // Enable GPIO Port E clock
    while ((SYSCTL_PRGPIO_R & 0x10) == 0); // Wait for GPIOE ready

    GPIO_PORTE_AFSEL_R |= 0x0C;   // Enable alternate function on PE3, PE2
    GPIO_PORTE_DEN_R &= ~0x0C;    // Disable digital on PE3, PE2
    GPIO_PORTE_AMSEL_R |= 0x0C;   // Enable analog mode on PE3, PE2

    ADC0_ACTSS_R &= ~0x08;        // Disable sample sequencer 3
    ADC0_EMUX_R &= ~0xF000;       // Software trigger conversion
    ADC0_SSMUX3_R = 0;            // Default to channel AIN0 (PE3)
    ADC0_SSCTL3_R = 0x06;         // Set flag and end of conversion
    ADC0_ACTSS_R |= 0x08;         // Enable sample sequencer 3
}

uint32_t ADC_Read(uint8_t channel) {
    ADC0_SSMUX3_R = channel;         // Select ADC channel
    ADC0_PSSI_R = 0x08;              // Start sampling on SS3
    while ((ADC0_RIS_R & 0x08) == 0); // Wait for conversion
    uint32_t result = ADC0_SSFIFO3_R; // Read result
    ADC0_ISC_R = 0x08;               // Clear interrupt flag
    return result;
}

void update_IR_sensors(int *IR_FL, int *IR_FR) {
    *IR_FL = ADC_Read(0); // Read Front-Left IR sensor (PE3 / AIN0)
    *IR_FR = ADC_Read(1); // Read Front-Right IR sensor (PE2 / AIN1)
}

void move_forward(oi_t *sensor, int millimeters) {
    double sum = 0;
    int IR_FL, IR_FR;

    oi_setWheels(100, 100); // Move forward

    while (sum < millimeters) {
        oi_update(sensor);
        sum += sensor->distance;

        // Read IR sensors
        update_IR_sensors(&IR_FL, &IR_FR);

        // Object detection
        if (IR_FL < 500 || IR_FR < 500) { // Adjust threshold as needed
            oi_setWheels(0, 0); // Stop
            lcd_printf("Object detected! IR_FL: %d IR_FR: %d", IR_FL, IR_FR);
            return;
        }

        // Handle bumps
        if (sensor->bumpLeft) {
            move_backwards(sensor, 150);
            turn_clockwise(sensor, 250);
            move_forward(sensor, 250);
            turn_cclockwise(sensor, 250);
        } else if (sensor->bumpRight) {
            move_backwards(sensor, 150);
            turn_cclockwise(sensor, 250);
            move_forward(sensor, 250);
            turn_clockwise(sensor, 250);
        }
    }
    oi_setWheels(0, 0); // Stop
}

void move_backwards(oi_t *sensor, int millimeters) {
    double sum = 0;
    oi_setWheels(-100, -100); // Move backward

    while (sum > -millimeters) {
        oi_update(sensor);
        sum += sensor->distance;
    }
    oi_setWheels(0, 0); // Stop
}

void turn_clockwise(oi_t *sensor, int degrees) {
    double angle = 0;
    oi_setWheels(-100, 100); // Rotate clockwise

    while (angle > -degrees) {
        oi_update(sensor);
        angle += sensor->angle;
    }
    oi_setWheels(0, 0); // Stop
}

void turn_cclockwise(oi_t *sensor, int degrees) {
    double angle = 0;
    oi_setWheels(100, -100); // Rotate counter-clockwise

    while (angle < degrees) {
        oi_update(sensor);
        angle += sensor->angle;
    }
    oi_setWheels(0, 0); // Stop
}
